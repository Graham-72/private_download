<?php

/**
 * @file
 * Inspired by http://www.drupalcoder.com/story/406-mixing-private-and-public-downloads-in-drupal-6
 */

/**
 * Implements hook_permission().
 */
function private_download_permission() {
  return array(
    'access private download directory' => array(
      'title' => t('access private download directory'),
      'description' => t('Files contained in the private file system are only accessible to users with this permission.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function private_download_menu() {
  $items['admin/config/media/private_download'] = array(
    'title' => 'Private Download',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('private_download_admin_form'),
    'access arguments' => array('administer site configuration'),
    'description' => 'Manage private download configuration.',
    'file' => 'private_download.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_file_download().
 */
function private_download_file_download($uri) {
  // We only care about files in the private scheme.
  if (file_uri_scheme($uri) == 'private') {
    // Deny access?
    $access = module_invoke_all('private_download_access', file_uri_target($uri));
    $access[] = user_access('access private download directory');
    $allow = in_array(TRUE, $access, TRUE);
    $deny = in_array(FALSE, $access, TRUE);
    $priority = variable_get('private_download_allowdeny_priority', 'deny');
    if ($priority == 'allow' && !$allow || $priority == 'deny' && $deny) {
      return -1;
    }

    // Check whether to serve file as attachment or inline.
    $type = file_get_mimetype($uri);
    $disposition_attachment = TRUE;
    if (variable_get('private_download_disposition', 'attachment') == 'inline') {
      $inline_patterns = variable_get('private_download_inline_patterns', array('^text/', '^image/', '\bflash$', '\bpdf$'));
      foreach ($inline_patterns as $pattern) {
        if (preg_match('`' . $pattern . '`', $type)) {
          $disposition_attachment = FALSE;
          break;
        }
      }
    }

    // Define default file header attributes.
    // We only send the "Content-Disposition" header field for disposition-type
    // "attachment". Otherwise, we unset it rather than sending a
    // disposition-type "inline", to minimize potential problems.
    $header = array(
      'Content-Type' => $type,
      'Content-Length' => filesize($uri),
      'Content-Disposition' => $disposition_attachment ? 'attachment; filename="' . mime_header_encode(drupal_basename($uri)) . '"' : '',
    );

    // Add user-defined file header attributes, if any.
    $user_defined_header = array();
    $private_download_header = variable_get('private_download_header', '');
    if (!empty($private_download_header)) {
      foreach (explode("\n", str_replace(array("\r\n", "\r"), "\n", $private_download_header)) as $attribute) {
        $components = explode(':', $attribute);
        if (count($components) == 2) {
          $user_defined_header[trim($components[0])] = trim($components[1]);
        }
      }
    }
    if (empty($user_defined_header)) {
      $user_defined_header = array(
        'Content-Transfer-Encoding' => 'binary',
        'Cache-Control' => 'private',
      );
    }
    return array_merge($header, $user_defined_header);
  }
}

/**
 * Write data to a file.
 *
 * @param string
 * @param string
 * @return boolean
 */
function private_download_write($filename, $content) {
  // Write content to file; create file if not present.
  $success = FALSE;
  if ($handle = @fopen($filename, 'w+b')) {
    $success = (fwrite($handle, $content) !== FALSE);
    fclose($handle);
  }
  return $success;
}

/**
 * Read data from a file.
 *
 * @param string
 * @return string or boolean
 */
function private_download_read($filename) {
  // Get file content into a string.
  $content = FALSE;
  if ($handle = @fopen($filename, 'r')) {
    $content = fread($handle, filesize($filename));
    fclose($handle);
  }
  return $content;
}
